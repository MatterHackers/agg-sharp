/*
The MIT License (MIT)

Copyright (c) 2014 Sebastian Loncar

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

See:
D. H. Laidlaw, W. B. Trumbore, and J. F. Hughes.
"Constructive Solid Geometry for Polyhedral Objects"
SIGGRAPH Proceedings, 1986, p.161.

original author: Danilo Balby Silva Castanheira (danbalby@yahoo.com)

Ported from Java to C# by Sebastian Loncar, Web: http://loncar.de
Optimized and refactored by: Lars Brubaker (larsbrubaker@matterhackers.com)
Project: https://github.com/MatterHackers/agg-sharp (an included library)
*/

using MatterHackers.VectorMath;
using System;
using System.Collections.Generic;
using System.Threading;

namespace Net3dBool
{
	/// <summary>
	/// Class used to apply boolean operations on solids.
	/// Two 'Solid' objects are submitted to this class constructor. There is a methods for
	/// each boolean operation. Each of these return a 'Solid' resulting from the application
	/// of its operation into the submitted solids.
	/// </summary>
	public class BooleanModeller
	{
		/** solid where boolean operations will be applied */
		private CancellationToken cancellationToken;
		private CsgObject3D object1;
		private CsgObject3D object1Copy;
		private CsgObject3D object2;

		private Action<string, double> reporter;

		/// <summary>
		/// Constructs a BooleanModeller object to apply boolean operation in two solids. Makes preliminary calculations
		/// </summary>
		/// <param name="solid1"></param>
		/// <param name="solid2"></param>
		public BooleanModeller(Solid solid1, Solid solid2)
			: this(solid1, solid2, null, CancellationToken.None)
		{
		}

		public BooleanModeller(Solid solid1, Solid solid2, Action<string, double> reporter, CancellationToken cancellationToken)
		{
			this.reporter = reporter;
			this.cancellationToken = cancellationToken;

			//representation to apply boolean operations
			reporter?.Invoke("Create Csg Object 1", 0.1);
			object1 = new CsgObject3D(solid1);

			reporter?.Invoke("Create Csg Object 2", 0.2);
			object2 = new CsgObject3D(solid2);

			object1Copy = new CsgObject3D(solid1);
		}

		private BooleanModeller()
		{
		}

		/// <summary>
		/// Action that receives the face being classified
		/// </summary>
		public static Action<CsgFace> Object1ClassifyFace { get; set; } = null;

		/// <summary>
		/// Action that receives the face being split and the face that is doing the splitting
		/// </summary>
		public static Action<CsgFace, CsgFace> Object1SplitFace { get; set; } = null;

		/// <summary>
		/// Action that receives the faces that are the results of the split that just occurred
		/// </summary>
		public static Action<List<CsgFace>> Object1SplitResults { get; set; } = null;

		public static Action<CsgFace> Object2ClassifyFace { get; set; } = null;

		public static Action<CsgFace, CsgFace> Object2SplitFace { get; set; } = null;

		public static Action<List<CsgFace>> Object2SplitResults { get; set; } = null;

		/// <summary>
		/// Gets the solid generated by the difference of the two solids submitted to the constructor.
		/// The fist solid has the second subtracted from it.
		/// </summary>
		/// <returns>solid generated by the difference of the two solids submitted to the constructor</returns>
		public Solid GetDifference()
		{
			PrepareData();
			reporter?.Invoke("Invert Inside Faces 1", .9);
			object2.InvertInsideFaces();
			Solid result = ComposeSolid(FaceStatus.Outside, FaceStatus.Opposite, FaceStatus.Inside);
			reporter?.Invoke("Invert Inside Faces 2", .9);
			object2.InvertInsideFaces();

			return result;
		}

		/// <summary>
		/// Gets the solid generated by the intersection of the two solids submitted to the constructor
		/// </summary>
		/// <returns>solid generated by the intersection of the two solids submitted to the constructor.
		/// The generated solid may be empty depending on the solids.
		/// To check this, use the Solid.isEmpty() method.</returns>
		public Solid GetIntersection()
		{
			PrepareData();
			return ComposeSolid(FaceStatus.Inside, FaceStatus.Same, FaceStatus.Inside);
		}

		/// <summary>
		/// Gets the solid generated by the union of the two solids submitted to the constructor
		/// </summary>
		/// <returns>solid generated by the union of the two solids submitted to the constructor</returns>
		public Solid GetUnion()
		{
			PrepareData();
			return ComposeSolid(FaceStatus.Outside, FaceStatus.Same, FaceStatus.Outside);
		}

		/// <summary>
		/// Composes a solid based on the faces status of the two operators solids
		/// </summary>
		/// <param name="faceStatus1">status expected for the first solid faces</param>
		/// <param name="faceStatus2">other status expected for the first solid faces
		/// (expected a status for the faces coincident with second solid faces)</param>
		/// <param name="faceStatus3">status expected for the second solid faces</param>
		/// <returns></returns>
		private Solid ComposeSolid(FaceStatus faceStatus1, FaceStatus faceStatus2, FaceStatus faceStatus3)
		{
			var vertices = new List<Vertex>();
			var indices = new List<int>();

			//group the elements of the two solids whose faces fit with the desired status
			reporter?.Invoke("Group Components 1", .9);
			GroupObjectComponents(object1, vertices, indices, faceStatus1, faceStatus2);
			reporter?.Invoke("Group Components 2", .9);
			GroupObjectComponents(object2, vertices, indices, faceStatus3, faceStatus3);

			//turn the arrayLists to arrays
			Vector3[] verticesArray = new Vector3[vertices.Count];
			for (int i = 0; i < vertices.Count; i++)
			{
				verticesArray[i] = vertices[i].Position;
			}
			int[] indicesArray = new int[indices.Count];
			for (int i = 0; i < indices.Count; i++)
			{
				indicesArray[i] = indices[i];
			}

			//returns the solid containing the grouped elements
			reporter?.Invoke("Create Solid", .9);
			return new Solid(verticesArray, indicesArray);
		}

		/// <summary>
		/// Fills solid arrays with data about faces of an object generated whose status is as required
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="vertices"></param>
		/// <param name="indices"></param>
		/// <param name="faceStatus1"></param>
		/// <param name="faceStatus2"></param>
		private void GroupObjectComponents(CsgObject3D obj, List<Vertex> vertices, List<int> indices, FaceStatus faceStatus1, FaceStatus faceStatus2)
		{
			var vertexIndexByHashCode = new Dictionary<Vector3, int>();
			//for each face..
			obj.Faces.All();
			foreach (CsgFace face in obj.Faces.QueryResults)
			{
				//if the face status fits with the desired status...
				if (face.Status == faceStatus1 || face.Status == faceStatus2)
				{
					//adds the face elements into the arrays
					Vertex[] faceVerts = { face.v1, face.v2, face.v3 };
					for (int j = 0; j < faceVerts.Length; j++)
					{
						if (vertexIndexByHashCode.ContainsKey(faceVerts[j].Position))
						{
							indices.Add(vertexIndexByHashCode[faceVerts[j].Position]);
						}
						else
						{
							vertexIndexByHashCode.Add(faceVerts[j].Position, vertices.Count);
							indices.Add(vertices.Count);
							vertices.Add(faceVerts[j]);
						}
					}
				}
			}
		}

		private void PrepareData()
		{
			if (object1Copy != null)
			{
				//split the faces so that none of them intercepts each other
				reporter?.Invoke("Split Faces 1", 0.4);
				object1.SplitFaces(object2, cancellationToken, Object1SplitFace, Object1SplitResults);

				reporter?.Invoke("Split Faces 2", 0.6);
				object2.SplitFaces(object1Copy, cancellationToken, Object2SplitFace, Object2SplitResults);
				// free the memory
				object1Copy = null;

				//classify faces as being inside or outside the other solid
				reporter?.Invoke("Classify Faces 1", 0.8);
				object1.ClassifyFaces(object2, cancellationToken, Object1ClassifyFace);

				reporter?.Invoke("Classify Faces 2", 0.9);
				object2.ClassifyFaces(object1, cancellationToken, Object2ClassifyFace);
			}
		}
	}
}